/******************************************************************
                Workshop 10 - Part 2

Name		   : Alejandro Mercado
Email	       : amercado-monetti@myseneca.ca
Student ID     : 123350233
Date Completed : 04/08/2024

I have done all the coding by myself and only copied the code that
my professor provided to complete my workshops and assignments.
*****************************************************************/

    1.- Code function templates

Function templates are very useful when needing the same logic to be applied when dealing with
multiple data types because the data types are defined until you're calling the templated functions.
In this workshop I had to create 2 templated functions:

    /**
	 * Searches for the specified element in an array and adds all found matches to a collection.
	 * 
	 * @tparam T - The type of elements stored in the Collection and the array. The Collection class must have an "add" method that takes an element of type T.
	 * @tparam U - The type of element to search for. Must be comparable to type T using the equality operator "==".
	 * @param col - A reference to a Collection object where the matching elements will be added.
	 * @param arr - The array of elements of type T to search.
	 * @param count - The number of elements in the array to search.
	 * @param srch - The element to search for in the array.
	 * @return true - The element is found in the array.
	 * @return false - The element is not found in the array.
	 *
	 */
	template <typename T, typename U>
	bool search(Collection<T>& col, T* arr, int count, const U srch) {
		bool found = false;
		for (auto i = 0; i < count; i++) {
			if (arr[i] == srch) {
				col.add(arr[i]);
				found = true;
			}
		}
		return found;
	}
	/**
	* Lists 'count"# of elements in an array printing each with a line number.
	*
	* @tparam T Type of elements in the array. It must support the "<<" operator overload.
	* @param title - The title to be printed before showing the list of elements.
	* @param arr - Pointer to an array of elements of type T.
	* @param count - The number of elements in the array.
	*
	*/
	template <typename T>
	void listArrayElements(const char* title, const T* arr, int count) {
		cout << title << endl;
		for (auto i = 0; i < count; i++) {
			cout << i + 1 << ": " << arr[i] << endl;
		}
	}

The first one had 2 data types that had to be determined: one for the Collection and array type,
and the other for the type of the search parameter. These templates were useful here because the
workshop was dealing with different classes but needed the same logic of finding matches in those
Colections.

    2.- Implement calls to function templates

When calling the templated functions, we have to specify the types for the arguments that we're
passing onto the function. There were different types of calls on the workshop that were implemented
in main.cpp:

	listArrayElements<Car>("All the cars:", C, 7)
	search<Car, const char*>(Cres, C, 8, "Tesla"

	listArrayElements<Student>("All students:", S, 6)
	search<Student, double>(Sres, S, 6, 4.0)

	listArrayElements<Employee>("All employees:", E, 6)
	search<Employee, int>(Eres, E, 6, 111)
	search<Employee, int>(Eres, E, 6, 555)

	listArrayElements<int>("INTEGERS", a, 6)

For each of these calls I had to specify the class of the collection and the array that I was passing
as arguments, and the class' implementation had to have a "==" operator overload and a "<<" operator
overload in order for the templated functions to work.

    3.- Project milestones

In the last milestone I have worked on (Milestone 4) there haven't been any template implementations,
and because all the classes work in a different way, there isn't really a need for them yet. That
being said, I do see how with a different implementation, the combination of ABC's with templated
functions and classes could be very useful in reducing code redundancy and making everything more
adaptable with functions whose logic doesn't go into the specifics of a class' members.